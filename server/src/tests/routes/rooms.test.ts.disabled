import { describe, it, expect, beforeEach, vi } from 'vitest';
import request from 'supertest';
import express from 'express';
import { roomRoutes } from '../../routes/rooms';
import { RoomModel } from '../../models/RoomModel';
import { authMiddleware } from '../../middleware/auth';

// Mock dependencies
vi.mock('../../models/RoomModel');
vi.mock('../../middleware/auth');

const app = express();
app.use(express.json());
app.use('/api/rooms', roomRoutes);

describe('Room Routes', () => {
  const mockUser = { id: 123, username: 'testuser' };
  
  beforeEach(() => {
    vi.clearAllMocks();
    
    // Mock auth middleware to add user to request
    vi.mocked(authMiddleware).mockImplementation((req: any, res: any, next: any) => {
      req.user = mockUser;
      next();
    });
  });

  describe('POST /api/rooms', () => {
    it('should create room successfully', async () => {
      const mockRoom = {
        id: 1,
        code: 'TEST01',
        name: 'Test Room',
        created_by: 123,
        max_players: 4,
        board_size: 4,
        status: 'waiting',
        members: [{ id: 123, username: 'testuser' }]
      };

      vi.mocked(RoomModel.create).mockResolvedValueOnce(mockRoom);
      vi.mocked(RoomModel.findByCode).mockResolvedValueOnce(mockRoom);

      const response = await request(app)
        .post('/api/rooms')
        .send({
          name: 'Test Room',
          max_players: 4,
          board_size: 4
        });

      expect(response.status).toBe(201);
      expect(response.body).toEqual({
        success: true,
        message: 'Room created successfully',
        room: mockRoom
      });
    });

    it('should validate required fields', async () => {
      const response = await request(app)
        .post('/api/rooms')
        .send({
          // Missing name
          max_players: 4
        });

      expect(response.status).toBe(400);
      expect(response.body.error).toBe('Invalid request');
    });

    it('should validate max_players range', async () => {
      const response = await request(app)
        .post('/api/rooms')
        .send({
          name: 'Test Room',
          max_players: 10 // Too high
        });

      expect(response.status).toBe(400);
      expect(response.body.error).toBe('Invalid request');
    });
  });

  describe('POST /api/rooms/:code/join', () => {
    const mockRoom = {
      id: 1,
      code: 'TEST01',
      name: 'Test Room',
      status: 'waiting',
      max_players: 4,
      members: []
    };

    it('should join room successfully when not a member', async () => {
      const roomWithMember = {
        ...mockRoom,
        members: [{ id: 123, username: 'testuser' }]
      };

      (RoomModel.findByCode as jest.Mock).mockResolvedValueOnce(mockRoom);
      (RoomModel.isUserInRoom as jest.Mock).mockResolvedValueOnce(false);
      (RoomModel.getMemberCount as jest.Mock).mockResolvedValueOnce(0);
      (RoomModel.addMember as jest.Mock).mockResolvedValueOnce(true);
      (RoomModel.findByCode as jest.Mock).mockResolvedValueOnce(roomWithMember);

      const response = await request(app)
        .post('/api/rooms/TEST01/join');

      expect(response.status).toBe(200);
      expect(response.body).toEqual({
        success: true,
        message: 'Successfully joined room',
        room: roomWithMember
      });
    });

    it('should return success when already a member (not error)', async () => {
      const roomWithMember = {
        ...mockRoom,
        members: [{ id: 123, username: 'testuser' }]
      };

      (RoomModel.findByCode as jest.Mock).mockResolvedValueOnce(mockRoom);
      (RoomModel.isUserInRoom as jest.Mock).mockResolvedValueOnce(true);
      (RoomModel.findByCode as jest.Mock).mockResolvedValueOnce(roomWithMember);

      const response = await request(app)
        .post('/api/rooms/TEST01/join');

      expect(response.status).toBe(200);
      expect(response.body).toEqual({
        success: true,
        message: 'Already a member of this room',
        room: roomWithMember
      });
    });

    it('should reject when room is full', async () => {
      (RoomModel.findByCode as jest.Mock).mockResolvedValueOnce(mockRoom);
      (RoomModel.isUserInRoom as jest.Mock).mockResolvedValueOnce(false);
      (RoomModel.getMemberCount as jest.Mock).mockResolvedValueOnce(4); // Full room

      const response = await request(app)
        .post('/api/rooms/TEST01/join');

      expect(response.status).toBe(400);
      expect(response.body).toEqual({
        error: 'Room full',
        message: 'This room has reached its maximum capacity'
      });
    });

    it('should reject when room is in game', async () => {
      const roomInGame = { ...mockRoom, status: 'in_game' };
      (RoomModel.findByCode as jest.Mock).mockResolvedValueOnce(roomInGame);

      const response = await request(app)
        .post('/api/rooms/TEST01/join');

      expect(response.status).toBe(400);
      expect(response.body).toEqual({
        error: 'Room not available',
        message: 'Room is not accepting new members'
      });
    });

    it('should handle room not found', async () => {
      (RoomModel.findByCode as jest.Mock).mockResolvedValueOnce(null);

      const response = await request(app)
        .post('/api/rooms/NOTFOUND/join');

      expect(response.status).toBe(404);
      expect(response.body).toEqual({
        error: 'Room not found'
      });
    });
  });

  describe('GET /api/rooms/:code', () => {
    it('should return room details successfully', async () => {
      const mockRoom = {
        id: 1,
        code: 'TEST01',
        name: 'Test Room',
        members: [{ id: 123, username: 'testuser' }]
      };

      (RoomModel.findByCode as jest.Mock).mockResolvedValueOnce(mockRoom);

      const response = await request(app)
        .get('/api/rooms/TEST01');

      expect(response.status).toBe(200);
      expect(response.body).toEqual({
        success: true,
        room: mockRoom
      });
    });

    it('should handle room not found', async () => {
      (RoomModel.findByCode as jest.Mock).mockResolvedValueOnce(null);

      const response = await request(app)
        .get('/api/rooms/NOTFOUND');

      expect(response.status).toBe(404);
      expect(response.body).toEqual({
        error: 'Room not found'
      });
    });
  });

  describe('GET /api/rooms', () => {
    it('should return list of active rooms', async () => {
      const mockRooms = [
        { id: 1, code: 'TEST01', name: 'Room 1', member_count: 2 },
        { id: 2, code: 'TEST02', name: 'Room 2', member_count: 1 }
      ];

      (RoomModel.getActiveRooms as jest.Mock).mockResolvedValueOnce(mockRooms);

      const response = await request(app)
        .get('/api/rooms');

      expect(response.status).toBe(200);
      expect(response.body).toEqual({
        success: true,
        rooms: mockRooms
      });
    });

    it('should return empty array when no rooms', async () => {
      (RoomModel.getActiveRooms as jest.Mock).mockResolvedValueOnce([]);

      const response = await request(app)
        .get('/api/rooms');

      expect(response.status).toBe(200);
      expect(response.body).toEqual({
        success: true,
        rooms: []
      });
    });
  });

  describe('DELETE /api/rooms/:code/leave', () => {
    it('should leave room successfully', async () => {
      const mockRoom = {
        id: 1,
        code: 'TEST01',
        name: 'Test Room'
      };

      (RoomModel.findByCode as jest.Mock).mockResolvedValueOnce(mockRoom);
      (RoomModel.removeMember as jest.Mock).mockResolvedValueOnce(true);

      const response = await request(app)
        .delete('/api/rooms/TEST01/leave');

      expect(response.status).toBe(200);
      expect(response.body).toEqual({
        success: true,
        message: 'Left room successfully'
      });
    });

    it('should handle room not found', async () => {
      (RoomModel.findByCode as jest.Mock).mockResolvedValueOnce(null);

      const response = await request(app)
        .delete('/api/rooms/NOTFOUND/leave');

      expect(response.status).toBe(404);
      expect(response.body).toEqual({
        error: 'Room not found'
      });
    });
  });
});